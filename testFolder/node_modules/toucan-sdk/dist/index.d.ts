/**
  The OffsetHelper's purpose is to simplify the carbon offsetting process.
  Copyright (C) 2022  Toucan Labs

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */
import "isomorphic-unfetch";
import { BigNumber, Contract, ContractReceipt, ethers } from "ethers";
import ContractInteractions from "./subclasses/ContractInteractions";
import SubgraphInteractions from "./subclasses/SubgraphInteractions";
import { IToucanCarbonOffsets, IToucanContractRegistry, IToucanPoolToken, OffsetHelper } from "./typechain";
import { Network, PoolSymbol } from "./types";
import { AggregationsMethod, AllTCO2TokensMethod, BridgedBatchTokensMethod, CustomQueryMethod, PoolContentsMethod, ProjectByIdMethod, RedeemsMethod, TCO2TokenByFullSymbolMethod, TCO2TokenByIdMethod, UserBatchesMethod, UserRedeemsMethod, UserRetirementsMethod } from "./types/methods";
/**
 *
 * @class ContractInteractions
 * @description This class wraps around classes that help users to interact with Toucan infrastructure
 * @implements ContractInteractions, SubgraphInteractions
 */
export default class ToucanClient {
    signer: ethers.Signer | undefined;
    provider: ethers.providers.Provider | undefined;
    network: Network;
    contractInteractions: ContractInteractions;
    subgraphInteractions: SubgraphInteractions;
    /**
     *
     * @param network network that you want to work on
     * @param provider to be able to read from the blockchain
     * @param signer to be able to sign transactions
     */
    constructor(network: Network, provider?: ethers.providers.Provider, signer?: ethers.Signer);
    setSigner: (signer: ethers.Signer) => void;
    setProvider: (provider: ethers.providers.Provider) => void;
    /**
     *
     * @description retires/burns an amount of TCO2s (each represents 1 ton of CO2) to achieve offset
     * @param amount amount of TCO2 to retire
     * @param tco2Address address of the TCO2 token to retire* @returns retirement transaction
     */
    retire: (amount: BigNumber, tco2Address: string) => Promise<ContractReceipt>;
    /**
     *
     * @description retires/burns an amount of TCO2s & mints the NFT certificate for it within the same transaction
     * @param retirementEntityName name of the entity that does the retirement (you)
     * @param beneficiaryAddress address of the beneficiary (in case you're retiring for someone else)
     * @param beneficiaryName name of the beneficiary
     * @param retirementMessage retirement message
     * @param amount amount of TCO2 to retire
     * @param tco2Address address of the TCO2 token to retire* @returns retirement transaction
     */
    retireAndMintCertificate: (retirementEntityName: string, beneficiaryAddress: string, beneficiaryName: string, retirementMessage: string, amount: BigNumber, tco2Address: string) => Promise<ContractReceipt>;
    /**
     *
     * @description retires/burns an amount of TCO2s from a different address/wallet
     * @notice requires approval from the address you're trying to retire from
     * @param amount amount of TCO2 to retire
     * @param address address of the account to retire from
     * @param tco2Address address of the TCO2 token to retire* @returns retirement transaction
     */
    retireFrom: (amount: BigNumber, address: string, tco2Address: string) => Promise<ContractReceipt>;
    /**
     *
     * @description gets the cap for TCO2s based on `totalVintageQuantity`
     * @param tco2Address address of the TCO2 token
     * @returns
     */
    getDepositCap: (tco2Address: string) => Promise<BigNumber>;
    /**
     *
     * @description gets the attributes of the project represented by the TCO2
     * @param tco2Address address of the TCO2 token
     * @returns an array of attributes
     */
    getAttributes: (tco2Address: string) => Promise<[[string, string, string, string, string, string, string, string, string, string] & {
        projectId: string;
        standard: string;
        methodology: string;
        region: string;
        storageMethod: string;
        method: string;
        emissionType: string;
        category: string;
        uri: string;
        controller: string;
    }, [string, BigNumber, BigNumber, BigNumber, BigNumber, boolean, boolean, string, string, string, string] & {
        name: string;
        startTime: BigNumber;
        endTime: BigNumber;
        projectTokenId: BigNumber;
        totalVintageQuantity: BigNumber;
        isCorsiaCompliant: boolean;
        isCCPcompliant: boolean;
        coBenefits: string;
        correspAdjustment: string;
        additionalCertification: string;
        uri: string;
    }]>;
    /**
     *
     * @description gets the remaining space in TCO2 contract before hitting the cap
     * @param tco2Address address of the TCO2 token
     * @returns BigNumber representing the remaining space
     */
    getTCO2Remaining: (tco2Address: string) => Promise<BigNumber>;
    /**
     *
     * @description deposits TCO2s in the pool which mints a pool token for the user
     * @param pool symbol of the pool (token) to use
     * @param amount amount of TCO2s to deposit
     * @param tco2Address address of the TCO2 token to deposit* @returns deposit transaction
     */
    depositTCO2: (pool: PoolSymbol, amount: BigNumber, tco2Address: string) => Promise<ContractReceipt>;
    /**
     *
     * @description checks if TCO2 is eligible for pool
     * @param pool symbol of the pool (token) to use
     * @param tco2 address of TCO2 to deposit
     * @returns boolean
     */
    checkEligible: (pool: PoolSymbol, tco2: string) => Promise<boolean>;
    /**
     *
     * @description calculates the fees to selectively redeem pool tokens for TCO2s
     * @param pool symbol of the pool (token) to use
     * @param tco2s array of TCO2 contract addresses
     * @param amounts array of amounts to redeem for each tco2s
     * @notice tco2s must match amounts; amounts[0] is the amount of tco2[0] token to redeem for
     * @returns amount (BigNumber) of fees it will cost to redeem
     */
    calculateRedeemFees: (pool: PoolSymbol, tco2s: string[], amounts: BigNumber[]) => Promise<BigNumber>;
    /**
     *
     * @description selectively redeems pool tokens for TCO2s
     * @param pool symbol of the pool (token) to use
     * @param tco2s array of TCO2 contract addresses
     * @param amounts array of amounts to redeem for each tco2s
     * @returns redeem transaction
     */
    redeemMany: (pool: PoolSymbol, tco2s: string[], amounts: BigNumber[]) => Promise<ContractReceipt>;
    /**
     *
     * @description automatically redeems pool tokens for TCO2s
     * @param pool symbol of the pool (token) to use
     * @param amount amount to redeem
     * @returns redeem transaction
     */
    redeemAuto: (pool: PoolSymbol, amount: BigNumber) => Promise<ContractReceipt>;
    /**
     *
     * @description automatically redeems pool tokens for TCO2s
     * @param pool symbol of the pool (token) to use
     * @param amount amount to redeem
     * @returns array containing tco2 addresses (string) and amounts (BigNumber)
     */
    redeemAuto2: (pool: PoolSymbol, amount: BigNumber) => Promise<{
        address: string;
        amount: BigNumber;
    }[]>;
    /**
     *
     * @description gets the remaining space in pool contract before hitting the cap
     * @param PoolSymbol symbol of the token to use
     * @returns BigNumber representing the remaining space
     */
    getPoolRemaining: (pool: PoolSymbol) => Promise<BigNumber>;
    /**
     *
     * @description gets an array of scored TCO2s; scoredTCO2s[0] is lowest ranked
     * @param pool symbol of the pool (token) to use
     * @returns array of TCO2 addresses by rank
     */
    getScoredTCO2s: (pool: PoolSymbol) => Promise<string[]>;
    /**
     *
     * @description checks if an address represents a TCO2
     * @param address address of contract to check
     * @returns boolean
     */
    checkIfTCO2: (address: string) => Promise<boolean>;
    /**
     *
     * @description allows user to retire carbon using carbon pool tokens from his wallet
     * @notice this method may take up to even 1 minute to give a result
     * @param pool symbol of the pool (token) to use
     * @param amount amount of CO2 tons to offset* @returns offset transaction
     */
    autoOffsetUsingPoolToken: (pool: PoolSymbol, amount: BigNumber) => Promise<ContractReceipt>;
    /**
     *
     * @description swaps given token for carbon pool tokens and uses them to retire carbon
     * @notice this method may take up to even 1 minute to give a result
     * @param pool symbol of the pool (token) to use
     * @param amount amount of CO2 tons to offset
     * @param swapToken portal for the token to swap into pool tokens (only accepts WETH, WMATIC and USDC)* @returns offset transaction
     */
    autoOffsetUsingSwapToken: (pool: PoolSymbol, amount: BigNumber, swapToken: Contract) => Promise<ContractReceipt>;
    /**
     *
     * @description swaps ETH for carbon pool tokens and uses them to retire carbon
     * @notice this method may take up to even 1 minute to give a result
     * @param pool symbol of the pool (token) to use
     * @param amount amount of CO2 tons to offset* @returns offset transaction
     */
    autoOffsetUsingETH: (pool: PoolSymbol, amount: BigNumber) => Promise<ContractReceipt>;
    /**
     *
     * @description calculates the needed amount of tokens to send to offset
     * @param pool symbol of the pool (token) to use
     * @param amount amount of CO2 tons to calculate for
     * @param swapToken contract of the token to use in swap
     * @returns amount (BigNumber) of swapToken needed to deposit
     */
    calculateNeededTokenAmount: (pool: PoolSymbol, amount: BigNumber, swapToken: Contract) => Promise<BigNumber>;
    /**
     *
     * @description calculates the needed amount of ETH to send to offset; ETH = native currency of network you are on
     * @param pool symbol of the pool (token) to use
     * @param amount amount of CO2 tons to calculate for
     * @returns amount (BigNumber) of ETH needed to deposit; ETH = native currency of network you are on
     */
    calculateNeededETHAmount: (pool: PoolSymbol, amount: BigNumber) => Promise<BigNumber>;
    /**
     *
     * @description fetches the batches of a user
     * @param walletAddress address of user to query for
     * @returns an array of BatchTokens (they contain different properties of the Batch)
     */
    fetchUserBatches: UserBatchesMethod;
    /**
     *
     * @description fetches properties of a TCO2
     * @param id id of the TCO2 to query for; the id happens to be the same as the address e.g.: "0x004090eef602e024b2a6cb7f0c1edda992382994"
     * @returns a TCO2Detail object with properties of the TCO2 (name, address, etc)
     */
    fetchTCO2TokenById: TCO2TokenByIdMethod;
    /**
     *
     * @description fetches properties of a TCO2
     * @param symbol full symbol of the TCO2 to query for e.g.: "TCO2-VCS-1718-2013"
     * @returns a TCO2Detail object with properties of the TCO2 (name, address, etc)
     */
    fetchTCO2TokenByFullSymbol: TCO2TokenByFullSymbolMethod;
    /**
     *
     * @description fetches TCO2Details of all TCO2s
     * @returns an array of TCO2Detail objects with properties of the TCO2s (name, address, etc)
     */
    fetchAllTCO2Tokens: AllTCO2TokensMethod;
    /**
     *
     * @description fetches data about BatchTokens that have been bridged
     * @returns an array of BatchTokens containing different properties like id, serialNumber or quantity
     */
    fetchBridgedBatchTokens: BridgedBatchTokensMethod;
    /**
     *
     * @description fetches retirements made by a user
     * @param walletAddress address of the user/wallet to query for
     * @param first how many retirements you want fetched; defaults to 100
     * @param skip how many (if any) retirements you want skipped; defaults to 0
     * @returns an array of objects containing properties of the retirements like id, creationTx, amount and more
     */
    fetchUserRetirements: UserRetirementsMethod;
    /**
     *
     * @description fetches redeems of a given pool
     * @param pool symbol of pool to fetch for
     * @param first how many redeems you want fetched; defaults to 100
     * @param skip how many (if any) redeems you want skipped; defaults to 0
     * @returns an array of objects with properties of the redeems like id, amount, timestamp and more
     */
    fetchRedeems: RedeemsMethod;
    /**
     *
     * @description fetches redeems of a given pool and user
     * @param walletAddress address of the user/wallet to query for
     * @param pool symbol of pool to fetch for
     * @param first how many redeems you want fetched; defaults to 100
     * @param skip how many (if any) redeems you want skipped; defaults to 0
     * @returns an array of objects with properties of the redeems like id, amount, timestamp and more
     */
    fetchUserRedeems: UserRedeemsMethod;
    /**
     *
     * @description fetches TCO2 tokens that are part of the given pool
     * @param pool symbol of the pool to fetch for
     * @param first how many TCO2 tokens you want fetched; defaults to 1000
     * @param skip how many (if any) retirements you want skipped; defaults to 0
     * @returns an array of objects representing TCO2 tokens and containing properties like name, amount, methodology and more
     */
    fetchPoolContents: PoolContentsMethod;
    /**
     *
     * @description fetches a project by its id
     * @param id id of the project to fetch; e.g.: "10"
     * @returns an object with properties of the Project like projectId, region, standard and more
     */
    fetchProjectById: ProjectByIdMethod;
    /**
     *
     * @description fetch all aggregations (including, for example, tco2TotalRetired or totalCarbonBridged)
     * @returns an array of Aggregation objects containing properties like id, key, value
     */
    fetchAggregations: AggregationsMethod;
    /**
     *
     * @description if pre-made queries to Toucan's Subgraph don't fit all your needs; use this for custom queries
     * @param query a gql formated GraphQL query
     * @param params any parameters you may want to pass to the query
     * @returns all data fetched from query; you can use generics to declare what type to expect (if you're a fan of TS)
     */
    fetchCustomQuery: CustomQueryMethod;
    fetchTokenPriceOnDex: (pool: PoolSymbol) => Promise<{
        price: number | null;
        url: string | null;
        liquidityUSD: number | null;
        volumeUSD: number | null;
    }>;
    /**
     *
     * @description gets the contract of a pool token based on the symbol
     * @param pool symbol of the pool (token) to use
     * @returns a ethers.contract to interact with the pool
     */
    getPoolAddress: (pool: PoolSymbol) => string;
    /**
     *
     * @dev
     * @description gets the contract of a pool token based on the symbol
     * @param PoolSymbol symbol of the pool (token) to use
     * @returns a ethers.contract to interact with the pool
     */
    getPoolContract: (pool: PoolSymbol) => IToucanPoolToken;
    /**
     *
     * @description gets the contract of a TCO2 token based on the address
     * @param address address of TCO2 ethers.Contract to insantiate
     * @returns a ethers.contract to interact with the token
     */
    getTCO2Contract: (address: string) => IToucanCarbonOffsets;
    /**
     *
     * @description gets the contract of a the Toucan contract registry
     * @returns a ethers.contract to interact with the contract registry
     */
    getRegistryContract: () => IToucanContractRegistry;
    /**
     *
     * @description gets the contract of a the OffsetHelper contract
     * @returns a ethers.contract to interact with the OffsetHelper
     */
    getOffsetHelperContract: () => OffsetHelper;
}
export * from "./types/responses";
