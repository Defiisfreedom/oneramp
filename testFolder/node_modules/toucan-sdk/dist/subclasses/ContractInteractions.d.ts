/**
  The OffsetHelper's purpose is to simplify the carbon offsetting process.
  Copyright (C) 2022  Toucan Labs

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */
import { BigNumber, Contract, ContractReceipt, ethers } from "ethers";
import { IToucanCarbonOffsets, IToucanContractRegistry, IToucanPoolToken, OffsetHelper } from "../typechain";
import { Network, PoolSymbol } from "../types";
import { IfcOneNetworksAddresses } from "../utils/addresses";
/**
 * @class ContractInteractions
 * @description This class helps interact with Toucan contracts
 */
declare class ContractInteractions {
    network: Network;
    addresses: IfcOneNetworksAddresses;
    /**
     *
     * @param network network that you want to work on
     */
    constructor(network: Network);
    /**
     *
     * @description retires/burns an amount of TCO2s (each represents 1 ton of CO2) to achieve offset
     * @param amount amount of TCO2 to retire
     * @param tco2Address address of the TCO2 token to retire
     * @param signer this being a write transaction, we need a signer
     * @returns retirement transaction
     */
    retire: (amount: BigNumber, tco2Address: string, signer: ethers.Signer) => Promise<ContractReceipt>;
    /**
     *
     * @description retires/burns an amount of TCO2s & mints the NFT certificate for it within the same transaction
     * @param retirementEntityName name of the entity that does the retirement (you)
     * @param beneficiaryAddress address of the beneficiary (in case you're retiring for someone else)
     * @param beneficiaryName name of the beneficiary
     * @param retirementMessage retirement message
     * @param amount amount of TCO2 to retire
     * @param tco2Address address of the TCO2 token to retire
     * @param signer this being a write transaction, we need a signer
     * @returns retirement transaction
     */
    retireAndMintCertificate: (retirementEntityName: string, beneficiaryAddress: string, beneficiaryName: string, retirementMessage: string, amount: BigNumber, tco2Address: string, signer: ethers.Signer) => Promise<ContractReceipt>;
    /**
     *
     * @description retires/burns an amount of TCO2s from a different address/wallet
     * @notice requires approval from the address you're trying to retire from
     * @param amount amount of TCO2 to retire
     * @param address address of the account to retire from
     * @param tco2Address address of the TCO2 token to retire
     * @param signer this being a write transaction, we need a signer
     * @returns retirement transaction
     */
    retireFrom: (amount: BigNumber, address: string, tco2Address: string, signer: ethers.Signer) => Promise<ContractReceipt>;
    /**
     *
     * @description gets the cap for TCO2s based on `totalVintageQuantity`
     * @param tco2Address address of the TCO2 token
     * @param signerOrProvider this being a read transaction, we need a signer or provider
     * @returns
     */
    getDepositCap: (tco2Address: string, signerOrProvider: ethers.Signer | ethers.providers.Provider) => Promise<BigNumber>;
    /**
     *
     * @description gets the attributes of the project represented by the TCO2
     * @param tco2Address address of the TCO2 token
     * @param signerOrProvider this being a read transaction, we need a signer or provider
     * @returns an array of attributes
     */
    getAttributes: (tco2Address: string, signerOrProvider: ethers.Signer | ethers.providers.Provider) => Promise<[[string, string, string, string, string, string, string, string, string, string] & {
        projectId: string;
        standard: string;
        methodology: string;
        region: string;
        storageMethod: string;
        method: string;
        emissionType: string;
        category: string;
        uri: string;
        controller: string;
    }, [string, BigNumber, BigNumber, BigNumber, BigNumber, boolean, boolean, string, string, string, string] & {
        name: string;
        startTime: BigNumber;
        endTime: BigNumber;
        projectTokenId: BigNumber;
        totalVintageQuantity: BigNumber;
        isCorsiaCompliant: boolean;
        isCCPcompliant: boolean;
        coBenefits: string;
        correspAdjustment: string;
        additionalCertification: string;
        uri: string;
    }]>;
    /**
     *
     * @description gets the remaining space in TCO2 contract before hitting the cap
     * @param tco2Address address of the TCO2 token
     * @param signerOrProvider this being a read transaction, we need a signer or provider
     * @returns BigNumber representing the remaining space
     */
    getTCO2Remaining: (tco2Address: string, signerOrProvider: ethers.Signer | ethers.providers.Provider) => Promise<BigNumber>;
    /**
     *
     * @description deposits TCO2s in the pool which mints a pool token for the user
     * @param pool symbol of the pool (token) to use
     * @param amount amount of TCO2s to deposit
     * @param tco2Address address of the TCO2 token to deposit
     * @param signer this being a write transaction, we need a signer
     * @returns deposit transaction
     */
    depositTCO2: (pool: PoolSymbol, amount: BigNumber, tco2Address: string, signer: ethers.Signer) => Promise<ContractReceipt>;
    /**
     *
     * @description checks if TCO2 is eligible for pool
     * @param pool symbol of the pool (token) to use
     * @param tco2 address of TCO2 to deposit
     * @returns boolean
     */
    checkEligible: (pool: PoolSymbol, tco2: string, signerOrProvider: ethers.Signer | ethers.providers.Provider) => Promise<boolean>;
    /**
     *
     * @description calculates the fees to selectively redeem pool tokens for TCO2s
     * @param pool symbol of the pool (token) to use
     * @param tco2s array of TCO2 contract addresses
     * @param amounts array of amounts to redeem for each tco2s
     * @notice tco2s must match amounts; amounts[0] is the amount of tco2[0] token to redeem for
     * @returns amount (BigNumber) of fees it will cost to redeem
     */
    /**
     *
     * @description calculates the fees to selectively redeem pool tokens for TCO2s
     * @param pool symbol of the pool (token) to use
     * @param tco2s array of TCO2 contract addresses
     * @param amounts array of amounts to redeem for each tco2s
     * @notice tco2s must match amounts; amounts[0] is the amount of tco2[0] token to redeem for
     * @param signerOrProvider this being a read transaction, we need a signer or provider
     * @returns amount (BigNumber) of fees it will cost to redeem
     */
    calculateRedeemFees: (pool: PoolSymbol, tco2s: string[], amounts: BigNumber[], signerOrProvider: ethers.Signer | ethers.providers.Provider) => Promise<BigNumber>;
    /**
     *
     * @description selectively redeems pool tokens for TCO2s
     * @param pool symbol of the pool (token) to use
     * @param tco2s array of TCO2 contract addresses
     * @param amounts array of amounts to redeem for each tco2s
     * @param signer this being a write transaction, we need a signer
     * @returns redeem transaction
     */
    redeemMany: (pool: PoolSymbol, tco2s: string[], amounts: BigNumber[], signer: ethers.Signer) => Promise<ContractReceipt>;
    /**
     *
     * @description automatically redeems pool tokens for TCO2s
     * @param pool symbol of the pool (token) to use
     * @param amount amount to redeem
     * @param signer this being a write transaction, we need a signer
     * @returns redeem transaction
     */
    redeemAuto: (pool: PoolSymbol, amount: BigNumber, signer: ethers.Signer) => Promise<ContractReceipt>;
    /**
     *
     * @description automatically redeems pool tokens for TCO2s
     * @param pool symbol of the pool (token) to use
     * @param amount amount to redeem
     * @param signer this being a write transaction, we need a signer
     * @returns array containing tco2 addresses (string) and amounts (BigNumber)
     */
    redeemAuto2: (pool: PoolSymbol, amount: BigNumber, signer: ethers.Signer) => Promise<{
        address: string;
        amount: BigNumber;
    }[]>;
    /**
     *
     * @description gets the remaining space in pool contract before hitting the cap
     * @param PoolSymbol symbol of the token to use
     * @param signerOrProvider this being a read transaction, we need a signer or provider
     * @returns BigNumber representing the remaining space
     */
    getPoolRemaining: (pool: PoolSymbol, signerOrProvider: ethers.Signer | ethers.providers.Provider) => Promise<BigNumber>;
    /**
     *
     * @description gets an array of scored TCO2s; scoredTCO2s[0] is lowest ranked
     * @param pool symbol of the pool (token) to use
     * @param signerOrProvider this being a read transaction, we need a signer or provider
     * @returns array of TCO2 addresses by rank
     */
    getScoredTCO2s: (pool: PoolSymbol, signerOrProvider: ethers.Signer | ethers.providers.Provider) => Promise<string[]>;
    /**
     *
     * @description checks if an address represents a TCO2
     * @param address address of contract to check
     * @param signerOrProvider this being a read transaction, we need a signer or provider
     * @returns boolean
     */
    checkIfTCO2: (address: string, signerOrProvider: ethers.Signer | ethers.providers.Provider) => Promise<boolean>;
    /**
     *
     * @description allows user to retire carbon using carbon pool tokens from his wallet
     * @notice this method may take up to even 1 minute to give a result
     * @param pool symbol of the pool (token) to use
     * @param amount amount of CO2 tons to offset
     * @param signer this being a write transaction, we need a signer
     * @returns offset transaction
     */
    autoOffsetUsingPoolToken: (pool: PoolSymbol, amount: BigNumber, signer: ethers.Signer) => Promise<ContractReceipt>;
    /**
     *
     * @description swaps given token for carbon pool tokens and uses them to retire carbon
     * @notice this method may take up to even 1 minute to give a result
     * @param pool symbol of the pool (token) to use
     * @param amount amount of CO2 tons to offset
     * @param swapToken portal for the token to swap into pool tokens (only accepts WETH, WMATIC and USDC)
     * @param signer this being a write transaction, we need a signer
     * @returns offset transaction
     */
    autoOffsetUsingSwapToken: (pool: PoolSymbol, amount: BigNumber, swapToken: Contract, signer: ethers.Signer) => Promise<ContractReceipt>;
    /**
     *
     * @description swaps ETH for carbon pool tokens and uses them to retire carbon
     * @notice this method may take up to even 1 minute to give a result
     * @param pool symbol of the pool (token) to use
     * @param amount amount of CO2 tons to offset
     * @param signer this being a write transaction, we need a signer
     * @returns offset transaction
     */
    autoOffsetUsingETH: (pool: PoolSymbol, amount: BigNumber, signer: ethers.Signer) => Promise<ContractReceipt>;
    /**
     *
     * @description calculates the needed amount of tokens to send to offset
     * @param pool symbol of the pool (token) to use
     * @param amount amount of CO2 tons to calculate for
     * @param swapToken contract of the token to use in swap
     * @param signerOrProvider this being a read transaction, we need a signer or provider
     * @returns amount (BigNumber) of swapToken needed to deposit
     */
    calculateNeededTokenAmount: (pool: PoolSymbol, amount: BigNumber, swapToken: Contract, signerOrProvider: ethers.Signer | ethers.providers.Provider) => Promise<BigNumber>;
    /**
     *
     * @description calculates the needed amount of ETH to send to offset; ETH = native currency of network you are on
     * @param pool symbol of the pool (token) to use
     * @param amount amount of CO2 tons to calculate for
     * @param signerOrProvider this being a read transaction, we need a signer or provider
     * @returns amount (BigNumber) of ETH needed to deposit; ETH = native currency of network you are on
     */
    calculateNeededETHAmount: (pool: PoolSymbol, amount: BigNumber, signerOrProvider: ethers.Signer | ethers.providers.Provider) => Promise<BigNumber>;
    /**
     *
     * @description gets the contract of a pool token based on the symbol
     * @param pool symbol of the pool (token) to use
     * @returns a ethers.contract to interact with the pool
     */
    getPoolAddress: (pool: PoolSymbol) => string;
    /**
     *
     * @dev
     * @description gets the contract of a pool token based on the symbol
     * @param PoolSymbol symbol of the pool (token) to use
     * @param signerOrProvider depending on what you intend to do with the contract, a signer or provider
     * @returns a ethers.contract to interact with the pool
     */
    getPoolContract: (pool: PoolSymbol, signerOrProvider: ethers.Signer | ethers.providers.Provider) => IToucanPoolToken;
    /**
     *
     * @description gets the contract of a TCO2 token based on the address
     * @param address address of TCO2 ethers.Contract to insantiate
     * @param signerOrProvider depending on what you intend to do with the contract, a signer or provider
     * @returns a ethers.contract to interact with the token
     */
    getTCO2Contract: (address: string, signerOrProvider: ethers.Signer | ethers.providers.Provider) => IToucanCarbonOffsets;
    /**
     *
     * @description gets the contract of a the Toucan contract registry
     * @param signerOrProvider depending on what you intend to do with the contract, a signer or provider
     * @returns a ethers.contract to interact with the contract registry
     */
    getRegistryContract: (signerOrProvider: ethers.Signer | ethers.providers.Provider) => IToucanContractRegistry;
    /**
     *
     * @description gets the contract of a the OffsetHelper contract
     * @param signerOrProvider depending on what you intend to do with the contract, a signer or provider
     * @returns a ethers.contract to interact with the OffsetHelper
     */
    getOffsetHelperContract: (signerOrProvider: ethers.Signer | ethers.providers.Provider) => OffsetHelper;
}
export default ContractInteractions;
