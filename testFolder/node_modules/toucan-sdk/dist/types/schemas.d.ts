/**
  The OffsetHelper's purpose is to simplify the carbon offsetting process.
  Copyright (C) 2022  Toucan Labs

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */
import { RetirementStatus } from ".";
/**
 *
 * While it's true that using schemas adds the need to use Pick (see types/methods.ts) and that is verbose,
 * it does improve future consistency in the codebase.
 *
 * I've had a hard time fixing GraphQL syntax, typescript compile errors and bringing consistency
 * to the coding style of the methods I've copied from tokenizer for querying the subgraph.
 *
 * With that in mind, I think enforcing the use of Pick and of interfaces (like below) that match
 * the GraphQL schemas will make the codebase more maintainable long-term.
 *
 * P.S.: You'd be surpised how many errors came not having TS Strict or from having interfaces
 * that didn't account for the fact that certain properties in the query are nullable.
 *
 */
export interface BatchTokenSchema {
    id: string;
    creator: UserSchema;
    owner: UserSchema;
    projectVintage?: ProjectVintageSchema;
    serialNumber?: string;
    quantity?: number;
    confirmationStatus: RetirementStatus;
    timestamp: number;
    tx: string;
    contentURI?: string;
    comments: BatchCommentSchema[];
    aggregated?: boolean;
}
export interface RetirementSchema {
    id: string;
    creationTx: string;
    amount: string;
    timestamp: string;
    token: TCO2TokenSchema;
    creator: UserSchema;
    eventId: string;
    certificate?: RetirementCertificateSchema;
}
export interface UserSchema {
    id: string;
    batchesOwned: BatchTokenSchema[];
    batchesCreated: BatchTokenSchema[];
    batchComments: BatchCommentSchema[];
    projectsOwned: ProjectSchema[];
    projectsCreated: ProjectSchema[];
    vintagesOwned: ProjectVintageSchema[];
    vintagesCreated: ProjectVintageSchema[];
    retirementsCreated: RetirementSchema[];
    redeemsCreated: RedeemSchema[];
    tokensOwned?: TCO2BalanceSchema[];
}
export interface BatchCommentSchema {
    id: string;
    sender?: UserSchema;
    batch: BatchTokenSchema;
    comment: string;
}
export interface TCO2BalanceSchema {
    id: string;
    user: UserSchema;
    token: TCO2TokenSchema;
    balance: string;
}
export interface RetirementCertificateSchema {
    id: string;
    creationTx: string;
    updateTxs: string[];
    createdAt: string;
    retiringEntity: UserSchema;
    beneficiary: UserSchema;
    retiringEntityString: string;
    beneficiaryString: string;
    retirementMessage: string;
    retirements: RetirementSchema[];
}
export interface ProjectSchema {
    id: string;
    creator: UserSchema;
    owner: UserSchema;
    timestamp: string;
    tx: string;
    projectId: string;
    vintages: ProjectVintageSchema[];
    standard: string;
    methodology?: string;
    region?: string;
    storageMethod?: string;
    method?: string;
    emissionType?: string;
    category?: string;
    uri?: string;
}
export interface TCO2TokenSchema {
    id: string;
    creator: UserSchema;
    createdAt: string;
    creationTx: string;
    projectVintage: ProjectVintageSchema;
    name: string;
    symbol: string;
    address: string;
    score: string;
}
export interface PooledTCO2TokenSchema {
    id: string;
    token: TCO2TokenSchema;
    poolAddress: string;
    amount: string;
}
export interface ProjectVintageSchema {
    id: string;
    creator: UserSchema;
    owner: UserSchema;
    timestamp: string;
    tx: string;
    name: string;
    startTime: string;
    endTime: string;
    project?: ProjectSchema;
    batches: BatchTokenSchema[];
    totalVintageQuantity: string;
    isCorsiaCompliant: boolean;
    isCCPcompliant: boolean;
    coBenefits: string;
    correspAdjustment: string;
    additionalCertification: string;
    issuanceDate: string;
    tco2Token?: TCO2TokenSchema;
}
export interface RedeemSchema {
    id: string;
    amount: string;
    timestamp: string;
    token: TCO2TokenSchema;
    pool: string;
    creator: UserSchema;
}
export interface AggregationsSchema {
    id: string;
    key: string;
    value: string;
}
export interface PairSchema {
    id: string;
    factory: Factory;
    name: string;
    token0: TokenSchema;
    token1: TokenSchema;
    reserve0: string;
    reserve1: string;
    totalSupply: string;
    reserveETH: string;
    reserveUSD: string;
    trackedReserveETH: string;
    token0Price: string;
    token1Price: string;
    volumeToken0: string;
    volumeToken1: string;
    volumeUSD: string;
    untrackedVolumeUSD: string;
    txCount: string;
    liquidityProviderCount: string;
    liquidityPositions: LiquidityPosition[];
    liquidityPositionSnapshots: LiquidityPositionSnapshot[];
    dayData: PairDayData[];
    hourData: PairHourData[];
    mints: Mint[];
    burns: Burn[];
    swaps: Swap[];
    timestamp: string;
    block: string;
}
export interface TokenSchema {
    id: string;
    factory: Factory;
    symbol: string;
    name: string;
    decimals: string;
    totalSupply: string;
    volume: string;
    volumeUSD: string;
    untrackedVolumeUSD: string;
    txCount: string;
    liquidity: string;
    derivedETH: string;
    whitelistPairs: PairSchema;
    hourData: TokenHourData;
    dayData: TokenDayData;
    basePairs: PairSchema;
    quotePairs: PairSchema;
    basePairsDayData: PairDayData;
    quotePairsDayData: PairDayData;
}
declare type Factory = unknown;
declare type LiquidityPosition = unknown;
declare type LiquidityPositionSnapshot = unknown;
declare type PairDayData = unknown;
declare type PairHourData = unknown;
declare type Mint = unknown;
declare type Burn = unknown;
declare type Swap = unknown;
declare type TokenHourData = unknown;
declare type TokenDayData = unknown;
export {};
